diff -up vlc-2.2.1/configure.ac.ffmpeg vlc-2.2.1/configure.ac
--- vlc-2.2.1/configure.ac.ffmpeg	2015-11-08 20:50:07.807850362 -0200
+++ vlc-2.2.1/configure.ac	2015-11-08 20:51:31.591175873 -0200
@@ -2314,8 +2314,8 @@ AC_ARG_ENABLE(avcodec,
 [  --enable-avcodec        libavcodec codec (default enabled)])
 AS_IF([test "${enable_avcodec}" != "no"], [
   PKG_CHECK_MODULES(AVCODEC,[libavcodec >= 53.34.0 libavutil >= 51.22.0], [
-    dnl PKG_CHECK_EXISTS([libavcodec < 56],, [
-    dnl   AC_MSG_ERROR([libavcodec versions 56 and later are not supported yet.])
+    dnl PKG_CHECK_EXISTS([libavcodec < 58],, [
+    dnl   AC_MSG_ERROR([libavcodec versions 58 and later are not supported yet.])
     dnl ])
     VLC_SAVE_FLAGS
     CPPFLAGS="${CPPFLAGS} ${AVCODEC_CFLAGS}"
diff -up vlc-2.2.1/modules/codec/avcodec/audio.c.ffmpeg vlc-2.2.1/modules/codec/avcodec/audio.c
--- vlc-2.2.1/modules/codec/avcodec/audio.c.ffmpeg	2015-11-08 20:57:42.238985964 -0200
+++ vlc-2.2.1/modules/codec/avcodec/audio.c	2015-11-08 20:57:49.284499679 -0200
@@ -39,8 +39,6 @@
 #include <libavcodec/avcodec.h>
 #include <libavutil/mem.h>
 
-#include <libavutil/audioconvert.h>
-
 #include "avcodec.h"
 
 /*****************************************************************************
diff -up vlc-2.2.1/modules/codec/avcodec/avcodec.c.ffmpeg vlc-2.2.1/modules/codec/avcodec/avcodec.c
diff -up vlc-2.2.1/modules/codec/avcodec/avcommon_compat.h.ffmpeg vlc-2.2.1/modules/codec/avcodec/avcommon_compat.h
--- vlc-2.2.1/modules/codec/avcodec/avcommon_compat.h.ffmpeg	2015-03-01 11:07:35.000000000 -0300
+++ vlc-2.2.1/modules/codec/avcodec/avcommon_compat.h	2015-11-08 20:47:05.348341058 -0200
@@ -2,7 +2,7 @@
  * avcodec.h: decoder and encoder using libavcodec
  *****************************************************************************
  * Copyright (C) 2001-2013 VLC authors and VideoLAN
- * $Id: 3fc14dc163885eb5ac80d955e3159a506f0dcfed $
+ * $Id$
  *
  * Authors: Laurent Aimar <fenrir@via.ecp.fr>
  *          Jean-Baptiste Kempf <jb@videolan.org>
@@ -36,447 +36,24 @@
     ( (LIBAVCODEC_VERSION_MICRO <  100 && LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( a, b, c ) ) || \
       (LIBAVCODEC_VERSION_MICRO >= 100 && LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( a, d, e ) ) )
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-#   define AV_PICTURE_TYPE_B        FF_B_TYPE
-#   define AV_PICTURE_TYPE_I        FF_I_TYPE
-#   define AV_PICTURE_TYPE_P        FF_P_TYPE
-
-#   define AV_SAMPLE_FMT_NONE       SAMPLE_FMT_NONE
-#   define AV_SAMPLE_FMT_U8         SAMPLE_FMT_U8
-#   define AV_SAMPLE_FMT_S16        SAMPLE_FMT_S16
-#   define AV_SAMPLE_FMT_S32        SAMPLE_FMT_S32
-#   define AV_SAMPLE_FMT_FLT        SAMPLE_FMT_FLT
-#   define AV_SAMPLE_FMT_DBL        SAMPLE_FMT_DBL
+#if !LIBAVCODEC_VERSION_CHECK( 55, 52, 0, 63, 100 )
 
-#ifndef AV_CH_FRONT_LEFT
-#   define AV_CH_FRONT_LEFT         CH_FRONT_LEFT
-#endif
-#ifndef AV_CH_FRONT_RIGHT
-#   define AV_CH_FRONT_RIGHT        CH_FRONT_RIGHT
-#endif
-#ifndef AV_CH_FRONT_CENTER
-#   define AV_CH_FRONT_CENTER       CH_FRONT_CENTER
-#endif
-#ifndef AV_CH_LOW_FREQUENCY
-#   define AV_CH_LOW_FREQUENCY      CH_LOW_FREQUENCY
-#endif
-#ifndef AV_CH_BACK_LEFT
-#   define AV_CH_BACK_LEFT          CH_BACK_LEFT
-#endif
-#ifndef AV_CH_BACK_RIGHT
-#   define AV_CH_BACK_RIGHT         CH_BACK_RIGHT
-#endif
-#ifndef AV_CH_FRONT_LEFT_OF_CENTER
-#   define AV_CH_FRONT_LEFT_OF_CENTER  CH_FRONT_LEFT_OF_CENTER
-#endif
-#ifndef AV_CH_FRONT_RIGHT_OF_CENTER
-#   define AV_CH_FRONT_RIGHT_OF_CENTER CH_FRONT_RIGHT_OF_CENTER
-#endif
-#ifndef AV_CH_BACK_CENTER
-#   define AV_CH_BACK_CENTER        CH_BACK_CENTER
-#endif
-#ifndef AV_CH_SIDE_LEFT
-#   define AV_CH_SIDE_LEFT          CH_SIDE_LEFT
-#endif
-#ifndef AV_CH_SIDE_RIGHT
-#   define AV_CH_SIDE_RIGHT         CH_SIDE_RIGHT
-#endif
-#ifndef AV_CH_TOP_CENTER
-#   define AV_CH_TOP_CENTER         CH_TOP_CENTER
-#endif
-#ifndef AV_CH_TOP_FRONT_LEFT
-#   define AV_CH_TOP_FRONT_LEFT     CH_TOP_FRONT_LEFT
-#endif
-#ifndef AV_CH_TOP_FRONT_CENTER
-#   define AV_CH_TOP_FRONT_CENTER   CH_TOP_FRONT_CENTER
-#endif
-#ifndef AV_CH_TOP_FRONT_RIGHT
-#   define AV_CH_TOP_FRONT_RIGHT    CH_TOP_FRONT_RIGHT
-#endif
-#ifndef AV_CH_TOP_BACK_LEFT
-#   define AV_CH_TOP_BACK_LEFT      CH_TOP_BACK_LEFT
-#endif
-#ifndef AV_CH_TOP_BACK_CENTER
-#   define AV_CH_TOP_BACK_CENTER    CH_TOP_BACK_CENTER
-#endif
-#ifndef AV_CH_TOP_BACK_RIGHT
-#   define AV_CH_TOP_BACK_RIGHT     CH_TOP_BACK_RIGHT
-#endif
-#ifndef AV_CH_STEREO_LEFT
-#   define AV_CH_STEREO_LEFT        CH_STEREO_LEFT
-#endif
-#ifndef AV_CH_STEREO_RIGHT
-#   define AV_CH_STEREO_RIGHT       CH_STEREO_RIGHT
-#endif
-
-#endif /* LIBAVCODEC_VERSION_MAJOR < 54 */
-
-#if !LIBAVCODEC_VERSION_CHECK(54, 25, 0, 51, 100)
-#define AVCodecID CodecID
+#include <libavutil/mem.h>
 
-enum {
-    AV_CODEC_ID_NONE,
+static inline void avcodec_free_context( AVCodecContext **ctx )
+{
+    if( !*ctx )
+        return;
 
-    /* video codecs */
-    AV_CODEC_ID_MPEG1VIDEO,
-    AV_CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
-    AV_CODEC_ID_MPEG2VIDEO_XVMC,
-    AV_CODEC_ID_H261,
-    AV_CODEC_ID_H263,
-    AV_CODEC_ID_RV10,
-    AV_CODEC_ID_RV20,
-    AV_CODEC_ID_MJPEG,
-    AV_CODEC_ID_MJPEGB,
-    AV_CODEC_ID_LJPEG,
-    AV_CODEC_ID_SP5X,
-    AV_CODEC_ID_JPEGLS,
-    AV_CODEC_ID_MPEG4,
-    AV_CODEC_ID_RAWVIDEO,
-    AV_CODEC_ID_MSMPEG4V1,
-    AV_CODEC_ID_MSMPEG4V2,
-    AV_CODEC_ID_MSMPEG4V3,
-    AV_CODEC_ID_WMV1,
-    AV_CODEC_ID_WMV2,
-    AV_CODEC_ID_H263P,
-    AV_CODEC_ID_H263I,
-    AV_CODEC_ID_FLV1,
-    AV_CODEC_ID_SVQ1,
-    AV_CODEC_ID_SVQ3,
-    AV_CODEC_ID_DVVIDEO,
-    AV_CODEC_ID_HUFFYUV,
-    AV_CODEC_ID_CYUV,
-    AV_CODEC_ID_H264,
-    AV_CODEC_ID_INDEO3,
-    AV_CODEC_ID_VP3,
-    AV_CODEC_ID_THEORA,
-    AV_CODEC_ID_ASV1,
-    AV_CODEC_ID_ASV2,
-    AV_CODEC_ID_FFV1,
-    AV_CODEC_ID_4XM,
-    AV_CODEC_ID_VCR1,
-    AV_CODEC_ID_CLJR,
-    AV_CODEC_ID_MDEC,
-    AV_CODEC_ID_ROQ,
-    AV_CODEC_ID_INTERPLAY_VIDEO,
-    AV_CODEC_ID_XAN_WC3,
-    AV_CODEC_ID_XAN_WC4,
-    AV_CODEC_ID_RPZA,
-    AV_CODEC_ID_CINEPAK,
-    AV_CODEC_ID_WS_VQA,
-    AV_CODEC_ID_MSRLE,
-    AV_CODEC_ID_MSVIDEO1,
-    AV_CODEC_ID_IDCIN,
-    AV_CODEC_ID_8BPS,
-    AV_CODEC_ID_SMC,
-    AV_CODEC_ID_FLIC,
-    AV_CODEC_ID_TRUEMOTION1,
-    AV_CODEC_ID_VMDVIDEO,
-    AV_CODEC_ID_MSZH,
-    AV_CODEC_ID_ZLIB,
-    AV_CODEC_ID_QTRLE,
-    AV_CODEC_ID_SNOW,
-    AV_CODEC_ID_TSCC,
-    AV_CODEC_ID_ULTI,
-    AV_CODEC_ID_QDRAW,
-    AV_CODEC_ID_VIXL,
-    AV_CODEC_ID_QPEG,
-    AV_CODEC_ID_PNG,
-    AV_CODEC_ID_PPM,
-    AV_CODEC_ID_PBM,
-    AV_CODEC_ID_PGM,
-    AV_CODEC_ID_PGMYUV,
-    AV_CODEC_ID_PAM,
-    AV_CODEC_ID_FFVHUFF,
-    AV_CODEC_ID_RV30,
-    AV_CODEC_ID_RV40,
-    AV_CODEC_ID_VC1,
-    AV_CODEC_ID_WMV3,
-    AV_CODEC_ID_LOCO,
-    AV_CODEC_ID_WNV1,
-    AV_CODEC_ID_AASC,
-    AV_CODEC_ID_INDEO2,
-    AV_CODEC_ID_FRAPS,
-    AV_CODEC_ID_TRUEMOTION2,
-    AV_CODEC_ID_BMP,
-    AV_CODEC_ID_CSCD,
-    AV_CODEC_ID_MMVIDEO,
-    AV_CODEC_ID_ZMBV,
-    AV_CODEC_ID_AVS,
-    AV_CODEC_ID_SMACKVIDEO,
-    AV_CODEC_ID_NUV,
-    AV_CODEC_ID_KMVC,
-    AV_CODEC_ID_FLASHSV,
-    AV_CODEC_ID_CAVS,
-    AV_CODEC_ID_JPEG2000,
-    AV_CODEC_ID_VMNC,
-    AV_CODEC_ID_VP5,
-    AV_CODEC_ID_VP6,
-    AV_CODEC_ID_VP6F,
-    AV_CODEC_ID_TARGA,
-    AV_CODEC_ID_DSICINVIDEO,
-    AV_CODEC_ID_TIERTEXSEQVIDEO,
-    AV_CODEC_ID_TIFF,
-    AV_CODEC_ID_GIF,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_FFH264,
-#endif
-    AV_CODEC_ID_DXA,
-    AV_CODEC_ID_DNXHD,
-    AV_CODEC_ID_THP,
-    AV_CODEC_ID_SGI,
-    AV_CODEC_ID_C93,
-    AV_CODEC_ID_BETHSOFTVID,
-    AV_CODEC_ID_PTX,
-    AV_CODEC_ID_TXD,
-    AV_CODEC_ID_VP6A,
-    AV_CODEC_ID_AMV,
-    AV_CODEC_ID_VB,
-    AV_CODEC_ID_PCX,
-    AV_CODEC_ID_SUNRAST,
-    AV_CODEC_ID_INDEO4,
-    AV_CODEC_ID_INDEO5,
-    AV_CODEC_ID_MIMIC,
-    AV_CODEC_ID_RL2,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_8SVX_EXP,
-    AV_CODEC_ID_8SVX_FIB,
-#endif
-    AV_CODEC_ID_ESCAPE124,
-    AV_CODEC_ID_DIRAC,
-    AV_CODEC_ID_BFI,
-    AV_CODEC_ID_CMV,
-    AV_CODEC_ID_MOTIONPIXELS,
-    AV_CODEC_ID_TGV,
-    AV_CODEC_ID_TGQ,
-    AV_CODEC_ID_TQI,
-    AV_CODEC_ID_AURA,
-    AV_CODEC_ID_AURA2,
-    AV_CODEC_ID_V210X,
-    AV_CODEC_ID_TMV,
-    AV_CODEC_ID_V210,
-    AV_CODEC_ID_DPX,
-    AV_CODEC_ID_MAD,
-    AV_CODEC_ID_FRWU,
-    AV_CODEC_ID_FLASHSV2,
-    AV_CODEC_ID_CDGRAPHICS,
-    AV_CODEC_ID_R210,
-    AV_CODEC_ID_ANM,
-    AV_CODEC_ID_BINKVIDEO,
-    AV_CODEC_ID_IFF_ILBM,
-    AV_CODEC_ID_IFF_BYTERUN1,
-    AV_CODEC_ID_KGV1,
-    AV_CODEC_ID_YOP,
-    AV_CODEC_ID_VP8,
-    AV_CODEC_ID_PICTOR,
-    AV_CODEC_ID_ANSI,
-    AV_CODEC_ID_A64_MULTI,
-    AV_CODEC_ID_A64_MULTI5,
-    AV_CODEC_ID_R10K,
-    AV_CODEC_ID_MXPEG,
-    AV_CODEC_ID_LAGARITH,
-    AV_CODEC_ID_PRORES,
-    AV_CODEC_ID_JV,
-    AV_CODEC_ID_DFA,
-    AV_CODEC_ID_WMV3IMAGE,
-    AV_CODEC_ID_VC1IMAGE,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_G723_1,
-    AV_CODEC_ID_G729,
-#endif
-    AV_CODEC_ID_UTVIDEO,
-    AV_CODEC_ID_BMV_VIDEO,
-    AV_CODEC_ID_VBLE,
-    AV_CODEC_ID_DXTORY,
-    AV_CODEC_ID_V410,
-    AV_CODEC_ID_XWD,
-    AV_CODEC_ID_CDXL,
-    AV_CODEC_ID_XBM,
-    AV_CODEC_ID_ZEROCODEC,
-    AV_CODEC_ID_MSS1,
-    AV_CODEC_ID_MSA1,
-    AV_CODEC_ID_TSCC2,
-    AV_CODEC_ID_MTS2,
-    AV_CODEC_ID_CLLC,
-
-    /* various PAV_CM "codecs" */
-    AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
-    AV_CODEC_ID_PCM_S16LE = 0x10000,
-    AV_CODEC_ID_PCM_S16BE,
-    AV_CODEC_ID_PCM_U16LE,
-    AV_CODEC_ID_PCM_U16BE,
-    AV_CODEC_ID_PCM_S8,
-    AV_CODEC_ID_PCM_U8,
-    AV_CODEC_ID_PCM_MULAW,
-    AV_CODEC_ID_PCM_ALAW,
-    AV_CODEC_ID_PCM_S32LE,
-    AV_CODEC_ID_PCM_S32BE,
-    AV_CODEC_ID_PCM_U32LE,
-    AV_CODEC_ID_PCM_U32BE,
-    AV_CODEC_ID_PCM_S24LE,
-    AV_CODEC_ID_PCM_S24BE,
-    AV_CODEC_ID_PCM_U24LE,
-    AV_CODEC_ID_PCM_U24BE,
-    AV_CODEC_ID_PCM_S24DAUD,
-    AV_CODEC_ID_PCM_ZORK,
-    AV_CODEC_ID_PCM_S16LE_PLANAR,
-    AV_CODEC_ID_PCM_DVD,
-    AV_CODEC_ID_PCM_F32BE,
-    AV_CODEC_ID_PCM_F32LE,
-    AV_CODEC_ID_PCM_F64BE,
-    AV_CODEC_ID_PCM_F64LE,
-    AV_CODEC_ID_PCM_BLURAY,
-    AV_CODEC_ID_PCM_LXF,
-    AV_CODEC_ID_S302M,
-    AV_CODEC_ID_PCM_S8_PLANAR,
-
-    /* various ADPAV_CM codecs */
-    AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
-    AV_CODEC_ID_ADPCM_IMA_WAV,
-    AV_CODEC_ID_ADPCM_IMA_DK3,
-    AV_CODEC_ID_ADPCM_IMA_DK4,
-    AV_CODEC_ID_ADPCM_IMA_WS,
-    AV_CODEC_ID_ADPCM_IMA_SMJPEG,
-    AV_CODEC_ID_ADPCM_MS,
-    AV_CODEC_ID_ADPCM_4XM,
-    AV_CODEC_ID_ADPCM_XA,
-    AV_CODEC_ID_ADPCM_ADX,
-    AV_CODEC_ID_ADPCM_EA,
-    AV_CODEC_ID_ADPCM_G726,
-    AV_CODEC_ID_ADPCM_CT,
-    AV_CODEC_ID_ADPCM_SWF,
-    AV_CODEC_ID_ADPCM_YAMAHA,
-    AV_CODEC_ID_ADPCM_SBPRO_4,
-    AV_CODEC_ID_ADPCM_SBPRO_3,
-    AV_CODEC_ID_ADPCM_SBPRO_2,
-    AV_CODEC_ID_ADPCM_THP,
-    AV_CODEC_ID_ADPCM_IMA_AMV,
-    AV_CODEC_ID_ADPCM_EA_R1,
-    AV_CODEC_ID_ADPCM_EA_R3,
-    AV_CODEC_ID_ADPCM_EA_R2,
-    AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
-    AV_CODEC_ID_ADPCM_IMA_EA_EACS,
-    AV_CODEC_ID_ADPCM_EA_XAS,
-    AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
-    AV_CODEC_ID_ADPCM_IMA_ISS,
-    AV_CODEC_ID_ADPCM_G722,
-    AV_CODEC_ID_ADPCM_IMA_APC,
-
-    /* AMR */
-    AV_CODEC_ID_AMR_NB = 0x12000,
-    AV_CODEC_ID_AMR_WB,
-
-    /* RealAudio codecs*/
-    AV_CODEC_ID_RA_144 = 0x13000,
-    AV_CODEC_ID_RA_288,
-
-    /* various DPAV_CM codecs */
-    AV_CODEC_ID_ROQ_DPCM = 0x14000,
-    AV_CODEC_ID_INTERPLAY_DPCM,
-    AV_CODEC_ID_XAN_DPCM,
-    AV_CODEC_ID_SOL_DPCM,
-
-    /* audio codecs */
-    AV_CODEC_ID_MP2 = 0x15000,
-    AV_CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
-    AV_CODEC_ID_AAC,
-    AV_CODEC_ID_AC3,
-    AV_CODEC_ID_DTS,
-    AV_CODEC_ID_VORBIS,
-    AV_CODEC_ID_DVAUDIO,
-    AV_CODEC_ID_WMAV1,
-    AV_CODEC_ID_WMAV2,
-    AV_CODEC_ID_MACE3,
-    AV_CODEC_ID_MACE6,
-    AV_CODEC_ID_VMDAUDIO,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_SONIC,
-    AV_CODEC_ID_SONIC_LS,
-#endif
-    AV_CODEC_ID_FLAC,
-    AV_CODEC_ID_MP3ADU,
-    AV_CODEC_ID_MP3ON4,
-    AV_CODEC_ID_SHORTEN,
-    AV_CODEC_ID_ALAC,
-    AV_CODEC_ID_WESTWOOD_SND1,
-    AV_CODEC_ID_GSM, ///< as in Berlin toast format
-    AV_CODEC_ID_QDM2,
-    AV_CODEC_ID_COOK,
-    AV_CODEC_ID_TRUESPEECH,
-    AV_CODEC_ID_TTA,
-    AV_CODEC_ID_SMACKAUDIO,
-    AV_CODEC_ID_QCELP,
-    AV_CODEC_ID_WAVPACK,
-    AV_CODEC_ID_DSICINAUDIO,
-    AV_CODEC_ID_IMC,
-    AV_CODEC_ID_MUSEPACK7,
-    AV_CODEC_ID_MLP,
-    AV_CODEC_ID_GSM_MS, /* as found in WAV */
-    AV_CODEC_ID_ATRAC3,
-#if LIBAVCODEC_VERSION_MAJOR < 56
-    AV_CODEC_ID_VOXWARE,
+    av_free( (*ctx)->extradata );
+    av_free( *ctx );
+    *ctx = NULL;
+}
 #endif
-    AV_CODEC_ID_APE,
-    AV_CODEC_ID_NELLYMOSER,
-    AV_CODEC_ID_MUSEPACK8,
-    AV_CODEC_ID_SPEEX,
-    AV_CODEC_ID_WMAVOICE,
-    AV_CODEC_ID_WMAPRO,
-    AV_CODEC_ID_WMALOSSLESS,
-    AV_CODEC_ID_ATRAC3P,
-    AV_CODEC_ID_EAC3,
-    AV_CODEC_ID_SIPR,
-    AV_CODEC_ID_MP1,
-    AV_CODEC_ID_TWINVQ,
-    AV_CODEC_ID_TRUEHD,
-    AV_CODEC_ID_MP4ALS,
-    AV_CODEC_ID_ATRAC1,
-    AV_CODEC_ID_BINKAUDIO_RDFT,
-    AV_CODEC_ID_BINKAUDIO_DCT,
-    AV_CODEC_ID_AAC_LATM,
-    AV_CODEC_ID_QDMC,
-    AV_CODEC_ID_CELT,
-#if LIBAVCODEC_VERSION_MAJOR > 53
-    AV_CODEC_ID_G723_1,
-    AV_CODEC_ID_G729,
-    AV_CODEC_ID_8SVX_EXP,
-    AV_CODEC_ID_8SVX_FIB,
-#endif
-    AV_CODEC_ID_BMV_AUDIO,
-    AV_CODEC_ID_RALF,
-    AV_CODEC_ID_IAC,
-    AV_CODEC_ID_ILBC,
-
-    /* subtitle codecs */
-    AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
-    AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
-    AV_CODEC_ID_DVB_SUBTITLE,
-    AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
-    AV_CODEC_ID_XSUB,
-    AV_CODEC_ID_SSA,
-    AV_CODEC_ID_MOV_TEXT,
-    AV_CODEC_ID_HDMV_PGS_SUBTITLE,
-    AV_CODEC_ID_DVB_TELETEXT,
-    AV_CODEC_ID_SRT,
-
-    /* other specific kind of codecs (generally used for attachments) */
-    AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,           ///< A dummy ID pointing at the start of various fake codecs.
-    AV_CODEC_ID_TTF = 0x18000,
-
-    AV_CODEC_ID_PROBE = 0x19000, ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
-
-    AV_CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
-                                * stream (only used by libavformat) */
-    AV_CODEC_ID_MPEG4SYSTEMS = 0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
-                                * stream (only used by libavformat) */
-    AV_CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
-};
-
-#endif /* LIBAVCODEC_VERSION < 54.25 */
-
-#if LIBAVCODEC_VERSION_MAJOR < 54
-# define avcodec_alloc_context3(a) avcodec_alloc_context()
-# define avcodec_open2(a, b, c) avcodec_open(a, b)
-# define err_recognition error_recognition
+
+#if !LIBAVCODEC_VERSION_CHECK( 55, 28, 1, 45, 101 )
+# define av_frame_alloc avcodec_alloc_frame
+# define av_frame_free avcodec_free_frame
 #endif
 
 #endif /* HAVE_LIBAVCODEC_AVCODEC_H */
@@ -492,19 +69,20 @@ enum {
     ( (LIBAVUTIL_VERSION_MICRO <  100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( a, b, c ) ) || \
       (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( a, d, e ) ) )
 
-#if LIBAVUTIL_VERSION_MAJOR < 52 && !defined(AV_CPU_FLAG_MMXEXT)
-#   define AV_CPU_FLAG_MMXEXT       AV_CPU_FLAG_MMX2
-#endif
-
 #if !LIBAVUTIL_VERSION_CHECK( 52, 11, 0, 32, 100 )
 #   define AV_PIX_FMT_FLAG_HWACCEL  PIX_FMT_HWACCEL
 #endif
 
-#if !LIBAVUTIL_VERSION_CHECK( 51, 44, 0, 76, 100 )
-#   define av_pix_fmt_desc_get(a) &av_pix_fmt_descriptors[a]
+#endif /* HAVE_LIBAVUTIL_AVUTIL_H */
+
+#if LIBAVUTIL_VERSION_MAJOR >= 55
+# define FF_API_AUDIOCONVERT 1
 #endif
 
-#endif /* HAVE_LIBAVUTIL_AVUTIL_H */
+/* libavutil/pixfmt.h */
+#ifndef PixelFormat
+# define PixelFormat AVPixelFormat
+#endif
 
 #ifdef HAVE_LIBAVFORMAT_AVFORMAT_H
 # include <libavformat/avformat.h>
diff -up vlc-2.2.1/modules/codec/avcodec/chroma.c.ffmpeg vlc-2.2.1/modules/codec/avcodec/chroma.c
--- vlc-2.2.1/modules/codec/avcodec/chroma.c.ffmpeg	2014-11-16 16:57:58.000000000 -0200
+++ vlc-2.2.1/modules/codec/avcodec/chroma.c	2015-11-08 20:47:57.817272489 -0200
@@ -2,7 +2,7 @@
  * chroma.c: libavutil <-> libvlc conversion routines
  *****************************************************************************
  * Copyright (C) 1999-2008 VLC authors and VideoLAN
- * $Id: fbbe29a09856d1a872122fc0e9422c69a8cea082 $
+ * $Id$
  *
  * Authors: Laurent Aimar <fenrir@via.ecp.fr>
  *          Gildas Bazin <gbazin@videolan.org>
@@ -62,81 +62,80 @@ static const struct
 } chroma_table[] =
 {
     /* Planar YUV formats */
-    {VLC_CODEC_I444, PIX_FMT_YUV444P, 0, 0, 0 },
-    {VLC_CODEC_J444, PIX_FMT_YUVJ444P, 0, 0, 0 },
+    {VLC_CODEC_I444, AV_PIX_FMT_YUV444P, 0, 0, 0 },
+    {VLC_CODEC_J444, AV_PIX_FMT_YUVJ444P, 0, 0, 0 },
 
-    {VLC_CODEC_I440, PIX_FMT_YUV440P, 0, 0, 0 },
-    {VLC_CODEC_J440, PIX_FMT_YUVJ440P, 0, 0, 0 },
+    {VLC_CODEC_I440, AV_PIX_FMT_YUV440P, 0, 0, 0 },
+    {VLC_CODEC_J440, AV_PIX_FMT_YUVJ440P, 0, 0, 0 },
 
-    {VLC_CODEC_I422, PIX_FMT_YUV422P, 0, 0, 0 },
-    {VLC_CODEC_J422, PIX_FMT_YUVJ422P, 0, 0, 0 },
+    {VLC_CODEC_I422, AV_PIX_FMT_YUV422P, 0, 0, 0 },
+    {VLC_CODEC_J422, AV_PIX_FMT_YUVJ422P, 0, 0, 0 },
 
-    {VLC_CODEC_I420, PIX_FMT_YUV420P, 0, 0, 0 },
-    {VLC_CODEC_YV12, PIX_FMT_YUV420P, 0, 0, 0 },
-    {VLC_FOURCC('I','Y','U','V'), PIX_FMT_YUV420P, 0, 0, 0 },
-    {VLC_CODEC_J420, PIX_FMT_YUVJ420P, 0, 0, 0 },
-    {VLC_CODEC_I411, PIX_FMT_YUV411P, 0, 0, 0 },
-    {VLC_CODEC_I410, PIX_FMT_YUV410P, 0, 0, 0 },
-    {VLC_FOURCC('Y','V','U','9'), PIX_FMT_YUV410P, 0, 0, 0 },
-
-    {VLC_FOURCC('N','V','1','2'), PIX_FMT_NV12, 0, 0, 0 },
-    {VLC_FOURCC('N','V','2','1'), PIX_FMT_NV21, 0, 0, 0 },
-
-    {VLC_CODEC_I420_9L, PIX_FMT_YUV420P9LE, 0, 0, 0 },
-    {VLC_CODEC_I420_9B, PIX_FMT_YUV420P9BE, 0, 0, 0 },
-    {VLC_CODEC_I420_10L, PIX_FMT_YUV420P10LE, 0, 0, 0 },
-    {VLC_CODEC_I420_10B, PIX_FMT_YUV420P10BE, 0, 0, 0 },
-#if LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(51,13,0)
-    {VLC_CODEC_I422_9L, PIX_FMT_YUV422P9LE, 0, 0, 0 },
-    {VLC_CODEC_I422_9B, PIX_FMT_YUV422P9BE, 0, 0, 0 },
-#endif
-    {VLC_CODEC_I422_10L, PIX_FMT_YUV422P10LE, 0, 0, 0 },
-    {VLC_CODEC_I422_10B, PIX_FMT_YUV422P10BE, 0, 0, 0 },
+    {VLC_CODEC_I420, AV_PIX_FMT_YUV420P, 0, 0, 0 },
+    {VLC_CODEC_YV12, AV_PIX_FMT_YUV420P, 0, 0, 0 },
+    {VLC_FOURCC('I','Y','U','V'), AV_PIX_FMT_YUV420P, 0, 0, 0 },
+    {VLC_CODEC_J420, AV_PIX_FMT_YUVJ420P, 0, 0, 0 },
+    {VLC_CODEC_I411, AV_PIX_FMT_YUV411P, 0, 0, 0 },
+    {VLC_CODEC_I410, AV_PIX_FMT_YUV410P, 0, 0, 0 },
+    {VLC_FOURCC('Y','V','U','9'), AV_PIX_FMT_YUV410P, 0, 0, 0 },
+
+    {VLC_CODEC_NV12, AV_PIX_FMT_NV12, 0, 0, 0 },
+    {VLC_CODEC_NV21, AV_PIX_FMT_NV21, 0, 0, 0 },
+
+    {VLC_CODEC_I420_9L, AV_PIX_FMT_YUV420P9LE, 0, 0, 0 },
+    {VLC_CODEC_I420_9B, AV_PIX_FMT_YUV420P9BE, 0, 0, 0 },
+    {VLC_CODEC_I420_10L, AV_PIX_FMT_YUV420P10LE, 0, 0, 0 },
+    {VLC_CODEC_I420_10B, AV_PIX_FMT_YUV420P10BE, 0, 0, 0 },
+    {VLC_CODEC_I422_9L, AV_PIX_FMT_YUV422P9LE, 0, 0, 0 },
+    {VLC_CODEC_I422_9B, AV_PIX_FMT_YUV422P9BE, 0, 0, 0 },
+    {VLC_CODEC_I422_10L, AV_PIX_FMT_YUV422P10LE, 0, 0, 0 },
+    {VLC_CODEC_I422_10B, AV_PIX_FMT_YUV422P10BE, 0, 0, 0 },
 
-    {VLC_CODEC_YUV420A, PIX_FMT_YUVA420P, 0, 0, 0 },
-#if LIBAVUTIL_VERSION_CHECK( 51, 45, 0, 74, 100 )
+    {VLC_CODEC_YUV420A, AV_PIX_FMT_YUVA420P, 0, 0, 0 },
     {VLC_CODEC_YUV422A, AV_PIX_FMT_YUVA422P, 0, 0, 0 },
-#endif
+    {VLC_CODEC_YUVA,    AV_PIX_FMT_YUVA444P, 0, 0, 0 },
 
-    {VLC_CODEC_I444_9L, PIX_FMT_YUV444P9LE, 0, 0, 0 },
-    {VLC_CODEC_I444_9B, PIX_FMT_YUV444P9BE, 0, 0, 0 },
-    {VLC_CODEC_I444_10L, PIX_FMT_YUV444P10LE, 0, 0, 0 },
-    {VLC_CODEC_I444_10B, PIX_FMT_YUV444P10BE, 0, 0, 0 },
-    {VLC_CODEC_I444_16L, PIX_FMT_YUV444P16LE, 0, 0, 0 },
-    {VLC_CODEC_I444_16B, PIX_FMT_YUV444P16BE, 0, 0, 0 },
+    {VLC_CODEC_I444_9L, AV_PIX_FMT_YUV444P9LE, 0, 0, 0 },
+    {VLC_CODEC_I444_9B, AV_PIX_FMT_YUV444P9BE, 0, 0, 0 },
+    {VLC_CODEC_I444_10L, AV_PIX_FMT_YUV444P10LE, 0, 0, 0 },
+    {VLC_CODEC_I444_10B, AV_PIX_FMT_YUV444P10BE, 0, 0, 0 },
+    {VLC_CODEC_I444_16L, AV_PIX_FMT_YUV444P16LE, 0, 0, 0 },
+    {VLC_CODEC_I444_16B, AV_PIX_FMT_YUV444P16BE, 0, 0, 0 },
 
     /* Packed YUV formats */
-    {VLC_CODEC_YUYV, PIX_FMT_YUYV422, 0, 0, 0 },
-    {VLC_FOURCC('Y','U','Y','V'), PIX_FMT_YUYV422, 0, 0, 0 },
-    {VLC_CODEC_UYVY, PIX_FMT_UYVY422, 0, 0, 0 },
-    {VLC_FOURCC('Y','4','1','1'), PIX_FMT_UYYVYY411, 0, 0, 0 },
+    {VLC_CODEC_YUYV, AV_PIX_FMT_YUYV422, 0, 0, 0 },
+    {VLC_FOURCC('Y','U','Y','V'), AV_PIX_FMT_YUYV422, 0, 0, 0 },
+    {VLC_CODEC_UYVY, AV_PIX_FMT_UYVY422, 0, 0, 0 },
+    {VLC_FOURCC('Y','4','1','1'), AV_PIX_FMT_UYYVYY411, 0, 0, 0 },
 
     /* Packed RGB formats */
-    VLC_RGB( VLC_FOURCC('R','G','B','4'), PIX_FMT_RGB4, PIX_FMT_BGR4, 0x10, 0x06, 0x01 )
-    VLC_RGB( VLC_FOURCC('R','G','B','8'), PIX_FMT_RGB8, PIX_FMT_BGR8, 0xC0, 0x38, 0x07 )
+    VLC_RGB( VLC_FOURCC('R','G','B','4'), AV_PIX_FMT_RGB4, AV_PIX_FMT_BGR4, 0x10, 0x06, 0x01 )
+    VLC_RGB( VLC_CODEC_RGB8, AV_PIX_FMT_RGB8, AV_PIX_FMT_BGR8, 0xC0, 0x38, 0x07 )
 
-    VLC_RGB( VLC_CODEC_RGB15, PIX_FMT_RGB555, PIX_FMT_BGR555, 0x7c00, 0x03e0, 0x001f )
-    VLC_RGB( VLC_CODEC_RGB16, PIX_FMT_RGB565, PIX_FMT_BGR565, 0xf800, 0x07e0, 0x001f )
-    VLC_RGB( VLC_CODEC_RGB24, PIX_FMT_BGR24, PIX_FMT_RGB24, 0xff0000, 0x00ff00, 0x0000ff )
+    VLC_RGB( VLC_CODEC_RGB15, AV_PIX_FMT_RGB555, AV_PIX_FMT_BGR555, 0x7c00, 0x03e0, 0x001f )
+    VLC_RGB( VLC_CODEC_RGB16, AV_PIX_FMT_RGB565, AV_PIX_FMT_BGR565, 0xf800, 0x07e0, 0x001f )
+    VLC_RGB( VLC_CODEC_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGB24, 0xff0000, 0x00ff00, 0x0000ff )
 
-    VLC_RGB( VLC_CODEC_RGB32, PIX_FMT_RGB32, PIX_FMT_BGR32, 0x00ff0000, 0x0000ff00, 0x000000ff )
-    VLC_RGB( VLC_CODEC_RGB32, PIX_FMT_RGB32_1, PIX_FMT_BGR32_1, 0xff000000, 0x00ff0000, 0x0000ff00 )
+    VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_RGB32, AV_PIX_FMT_BGR32, 0x00ff0000, 0x0000ff00, 0x000000ff )
+    VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_RGB32_1, AV_PIX_FMT_BGR32_1, 0xff000000, 0x00ff0000, 0x0000ff00 )
 
 #ifdef AV_PIX_FMT_0BGR32
     VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_0BGR32, AV_PIX_FMT_0RGB32, 0x000000ff, 0x0000ff00, 0x00ff0000 )
 #endif
 
-    {VLC_CODEC_RGBA, PIX_FMT_RGBA, 0, 0, 0 },
-    {VLC_CODEC_ARGB, PIX_FMT_ARGB, 0, 0, 0 },
-    {VLC_CODEC_BGRA, PIX_FMT_BGRA, 0, 0, 0 },
-    {VLC_CODEC_GREY, PIX_FMT_GRAY8, 0, 0, 0},
+    {VLC_CODEC_RGBA, AV_PIX_FMT_RGBA, 0, 0, 0 },
+    {VLC_CODEC_ARGB, AV_PIX_FMT_ARGB, 0, 0, 0 },
+    {VLC_CODEC_BGRA, AV_PIX_FMT_BGRA, 0, 0, 0 },
+    {VLC_CODEC_GREY, AV_PIX_FMT_GRAY8, 0, 0, 0},
 
      /* Paletized RGB */
-    {VLC_CODEC_RGBP, PIX_FMT_PAL8, 0, 0, 0},
+    {VLC_CODEC_RGBP, AV_PIX_FMT_PAL8, 0, 0, 0},
 
-#if LIBAVUTIL_VERSION_CHECK(51, 42, 0, 74,100)
     {VLC_CODEC_GBR_PLANAR, AV_PIX_FMT_GBRP, 0, 0, 0 },
-#endif
+    {VLC_CODEC_GBR_PLANAR_9L, AV_PIX_FMT_GBRP9LE, 0, 0, 0 },
+    {VLC_CODEC_GBR_PLANAR_9B, AV_PIX_FMT_GBRP9BE, 0, 0, 0 },
+    {VLC_CODEC_GBR_PLANAR_10L, AV_PIX_FMT_GBRP10LE, 0, 0, 0 },
+    {VLC_CODEC_GBR_PLANAR_10B, AV_PIX_FMT_GBRP10BE, 0, 0, 0 },
 
     /* XYZ */
 #if LIBAVUTIL_VERSION_CHECK(52, 10, 0, 25, 100)
@@ -197,5 +196,5 @@ int FindFfmpegChroma( vlc_fourcc_t fourc
     for( int i = 0; chroma_table[i].i_chroma != 0; i++ )
         if( chroma_table[i].i_chroma == fourcc )
             return chroma_table[i].i_chroma_id;
-    return PIX_FMT_NONE;
+    return AV_PIX_FMT_NONE;
 }
diff -up vlc-2.2.1/modules/codec/avcodec/encoder.c.ffmpeg vlc-2.2.1/modules/codec/avcodec/encoder.c
--- vlc-2.2.1/modules/codec/avcodec/encoder.c.ffmpeg	2015-11-08 20:59:44.437207671 -0200
+++ vlc-2.2.1/modules/codec/avcodec/encoder.c	2015-11-08 21:01:37.992257911 -0200
@@ -41,7 +41,6 @@
 #include <vlc_cpu.h>
 
 #include <libavcodec/avcodec.h>
-#include <libavutil/audioconvert.h>
 
 #include "avcodec.h"
 #include "avcommon.h"
@@ -273,7 +272,7 @@ int OpenEncoder( vlc_object_t *p_this )
     else if( !GetFfmpegCodec( p_enc->fmt_out.i_codec, &i_cat, &i_codec_id,
                              &psz_namecodec ) )
     {
-        if( FindFfmpegChroma( p_enc->fmt_out.i_codec ) == PIX_FMT_NONE )
+        if( FindFfmpegChroma( p_enc->fmt_out.i_codec ) == AV_PIX_FMT_NONE )
             return VLC_EGENERIC; /* handed chroma output */
 
         i_cat      = VIDEO_ES;
@@ -994,7 +993,7 @@ errmsg:
         }
     }
 
-    p_sys->frame = avcodec_alloc_frame();
+    p_sys->frame = av_frame_alloc();
     if( !p_sys->frame )
     {
         goto error;
@@ -1063,7 +1062,7 @@ static block_t *EncodeVideo( encoder_t *
     AVFrame *frame = NULL;
     if( likely(p_pict) ) {
         frame = p_sys->frame;
-        avcodec_get_frame_defaults( frame );
+        av_frame_unref( frame );
         for( i_plane = 0; i_plane < p_pict->i_planes; i_plane++ )
         {
             p_sys->frame->data[i_plane] = p_pict->p[i_plane].p_pixels;
@@ -1298,7 +1297,7 @@ static block_t *handle_delay_buffer( enc
     //How much we need to copy from new packet
     const int leftover = leftover_samples * p_sys->p_context->channels * p_sys->i_sample_bytes;
 
-    avcodec_get_frame_defaults( p_sys->frame );
+    av_frame_unref( p_sys->frame );
     p_sys->frame->format     = p_sys->p_context->sample_fmt;
     p_sys->frame->nb_samples = leftover_samples + p_sys->i_samples_delay;
 
@@ -1420,7 +1419,7 @@ static block_t *EncodeAudio( encoder_t *
     while( ( p_aout_buf->i_nb_samples >= p_sys->i_frame_size ) ||
            ( p_sys->b_variable && p_aout_buf->i_nb_samples ) )
     {
-        avcodec_get_frame_defaults( p_sys->frame );
+        av_frame_unref( p_sys->frame );
         if( p_sys->b_variable )
             p_sys->frame->nb_samples = p_aout_buf->i_nb_samples;
         else
diff -up vlc-2.2.1/modules/codec/avcodec/vaapi.c.ffmpeg vlc-2.2.1/modules/codec/avcodec/vaapi.c
--- vlc-2.2.1/modules/codec/avcodec/vaapi.c.ffmpeg	2015-11-08 21:01:59.840640769 -0200
+++ vlc-2.2.1/modules/codec/avcodec/vaapi.c	2015-11-08 21:02:14.374564549 -0200
@@ -595,7 +595,7 @@ static int Create( vlc_va_t *p_va, AVCod
         return err;
 
     /* Only VLD supported */
-    p_va->pix_fmt = PIX_FMT_VAAPI_VLD;
+    p_va->pix_fmt = AV_PIX_FMT_VAAPI_VLD;
     p_va->setup = Setup;
     p_va->get = Get;
     p_va->release = Release;
diff -up vlc-2.2.1/modules/codec/avcodec/video.c.ffmpeg vlc-2.2.1/modules/codec/avcodec/video.c
--- vlc-2.2.1/modules/codec/avcodec/video.c.ffmpeg	2015-02-26 14:11:22.000000000 -0300
+++ vlc-2.2.1/modules/codec/avcodec/video.c	2015-11-08 21:03:24.014824639 -0200
@@ -223,7 +223,7 @@ int InitVideoDec( decoder_t *p_dec, AVCo
     p_sys->p_codec = p_codec;
     p_sys->i_codec_id = i_codec_id;
     p_sys->psz_namecodec = psz_namecodec;
-    p_sys->p_ff_pic = avcodec_alloc_frame();
+    p_sys->p_ff_pic = av_frame_alloc();
     p_sys->b_delayed_open = true;
     p_sys->p_va = NULL;
     vlc_sem_init( &p_sys->sem_mt, 0 );
@@ -435,7 +435,7 @@ int InitVideoDec( decoder_t *p_dec, AVCo
     if( ffmpeg_OpenCodec( p_dec ) < 0 )
     {
         msg_Err( p_dec, "cannot open codec (%s)", p_sys->psz_namecodec );
-        avcodec_free_frame( &p_sys->p_ff_pic );
+        av_frame_free( &p_sys->p_ff_pic );
         vlc_sem_destroy( &p_sys->sem_mt );
         free( p_sys );
         return VLC_EGENERIC;
@@ -815,7 +815,7 @@ void EndVideoDec( decoder_t *p_dec )
     wait_mt( p_sys );
 
     if( p_sys->p_ff_pic )
-        avcodec_free_frame( &p_sys->p_ff_pic );
+        av_frame_free( &p_sys->p_ff_pic );
 
     if( p_sys->p_va )
         vlc_va_Delete( p_sys->p_va );
@@ -993,7 +993,7 @@ static picture_t *lavc_dr_GetFrame(struc
     if (GetVlcChroma(&dec->fmt_out.video, ctx->pix_fmt) != VLC_SUCCESS)
         return NULL;
     dec->fmt_out.i_codec = dec->fmt_out.video.i_chroma;
-    if (ctx->pix_fmt == PIX_FMT_PAL8)
+    if (ctx->pix_fmt == AV_PIX_FMT_PAL8)
         return NULL;
 
     int width = frame->width;
@@ -1169,7 +1169,7 @@ static picture_t *ffmpeg_dr_GetFrameBuf(
     if (GetVlcChroma(&p_dec->fmt_out.video, p_context->pix_fmt) != VLC_SUCCESS)
         goto no_dr;
 
-    if (p_context->pix_fmt == PIX_FMT_PAL8)
+    if (p_context->pix_fmt == AV_PIX_FMT_PAL8)
         goto no_dr;
 
     p_dec->fmt_out.i_codec = p_dec->fmt_out.video.i_chroma;
@@ -1204,7 +1204,7 @@ static picture_t *ffmpeg_dr_GetFrameBuf(
             goto no_dr;
     }
 
-    if( p_context->pix_fmt == PIX_FMT_YUV422P )
+    if( p_context->pix_fmt == AV_PIX_FMT_YUV422P )
     {
         if( 2 * p_pic->p[1].i_pitch != p_pic->p[0].i_pitch ||
             2 * p_pic->p[2].i_pitch != p_pic->p[0].i_pitch )
@@ -1314,7 +1314,7 @@ static enum PixelFormat ffmpeg_GetFormat
 
     /* Enumerate available formats */
     bool can_hwaccel = false;
-    for( size_t i = 0; pi_fmt[i] != PIX_FMT_NONE; i++ )
+    for( size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++ )
     {
         const AVPixFmtDescriptor *dsc = av_pix_fmt_desc_get(pi_fmt[i]);
         if (dsc == NULL)
@@ -1341,7 +1341,7 @@ static enum PixelFormat ffmpeg_GetFormat
     if( p_va == NULL )
         goto end;
 
-    for( size_t i = 0; pi_fmt[i] != PIX_FMT_NONE; i++ )
+    for( size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++ )
     {
         if( p_va->pix_fmt != pi_fmt[i] )
             continue;
diff -up vlc-2.2.1/modules/video_chroma/swscale.c.ffmpeg vlc-2.2.1/modules/video_chroma/swscale.c
--- vlc-2.2.1/modules/video_chroma/swscale.c.ffmpeg	2015-11-08 20:39:18.848684257 -0200
+++ vlc-2.2.1/modules/video_chroma/swscale.c	2015-11-08 20:42:56.924726117 -0200
@@ -2,7 +2,7 @@
  * swscale.c: scaling and chroma conversion using libswscale
  *****************************************************************************
  * Copyright (C) 1999-2008 VLC authors and VideoLAN
- * $Id: f7f80826f1dc09dafb109ad2cb55b7ab5d5b9fd4 $
+ * $Id$
  *
  * Authors: Laurent Aimar <fenrir@via.ecp.fr>
  *          Gildas Bazin <gbazin@videolan.org>
@@ -36,6 +36,7 @@
 #include <vlc_cpu.h>
 
 #include <libswscale/swscale.h>
+#include <libswscale/version.h>
 
 #ifdef __APPLE__
 # include <TargetConditionals.h>
@@ -85,8 +86,7 @@ vlc_module_end ()
  */
 struct filter_sys_t
 {
-    SwsFilter *p_src_filter;
-    SwsFilter *p_dst_filter;
+    SwsFilter *p_filter;
     int i_cpu_mask, i_sws_flags;
 
     video_format_t fmt_in;
@@ -154,10 +154,8 @@ static int OpenScaler( vlc_object_t *p_t
                        &p_filter->fmt_out.video, 0 ) )
         return VLC_EGENERIC;
 
-    /* */
-    p_filter->pf_video_filter = Filter;
     /* Allocate the memory needed to store the decoder's structure */
-    if( ( p_filter->p_sys = p_sys = malloc(sizeof(filter_sys_t)) ) == NULL )
+    if( ( p_filter->p_sys = p_sys = calloc(1, sizeof(filter_sys_t)) ) == NULL )
         return VLC_ENOMEM;
 
     /* Set CPU capabilities */
@@ -181,27 +179,21 @@ static int OpenScaler( vlc_object_t *p_t
     default: p_sys->i_sws_flags = SWS_BICUBIC; i_sws_mode = 2; break;
     }
 
-    p_sys->p_src_filter = NULL;
-    p_sys->p_dst_filter = NULL;
-
     /* Misc init */
-    p_sys->ctx = NULL;
-    p_sys->ctxA = NULL;
-    p_sys->p_src_a = NULL;
-    p_sys->p_dst_a = NULL;
-    p_sys->p_src_e = NULL;
-    p_sys->p_dst_e = NULL;
     memset( &p_sys->fmt_in,  0, sizeof(p_sys->fmt_in) );
     memset( &p_sys->fmt_out, 0, sizeof(p_sys->fmt_out) );
 
     if( Init( p_filter ) )
     {
-        if( p_sys->p_src_filter )
-            sws_freeFilter( p_sys->p_src_filter );
+        if( p_sys->p_filter )
+            sws_freeFilter( p_sys->p_filter );
         free( p_sys );
         return VLC_EGENERIC;
     }
 
+    /* */
+    p_filter->pf_video_filter = Filter;
+
     msg_Dbg( p_filter, "%ix%i (%ix%i) chroma: %4.4s -> %ix%i (%ix%i) chroma: %4.4s with scaling using %s",
              p_filter->fmt_in.video.i_visible_width, p_filter->fmt_in.video.i_visible_height,
              p_filter->fmt_in.video.i_width, p_filter->fmt_in.video.i_height,
@@ -223,8 +215,8 @@ static void CloseScaler( vlc_object_t *p
     filter_sys_t *p_sys = p_filter->p_sys;
 
     Clean( p_filter );
-    if( p_sys->p_src_filter )
-        sws_freeFilter( p_sys->p_src_filter );
+    if( p_sys->p_filter )
+        sws_freeFilter( p_sys->p_filter );
     free( p_sys );
 }
 
@@ -235,6 +227,7 @@ static int GetSwsCpuMask(void)
 {
     int i_sws_cpu = 0;
 
+#if LIBSWSCALE_VERSION_MAJOR < 4
 #if defined(__i386__) || defined(__x86_64__)
     if( vlc_CPU_MMX() )
         i_sws_cpu |= SWS_CPU_CAPS_MMX;
@@ -248,6 +241,7 @@ static int GetSwsCpuMask(void)
     if( vlc_CPU_ALTIVEC() )
         i_sws_cpu |= SWS_CPU_CAPS_ALTIVEC;
 #endif
+#endif
 
     return i_sws_cpu;
 }
@@ -257,35 +251,35 @@ static void FixParameters( int *pi_fmt,
     switch( fmt )
     {
     case VLC_CODEC_YUV422A:
-        *pi_fmt = PIX_FMT_YUV422P;
+        *pi_fmt = AV_PIX_FMT_YUV422P;
         *pb_has_a = true;
         break;
     case VLC_CODEC_YUV420A:
-        *pi_fmt = PIX_FMT_YUV420P;
+        *pi_fmt = AV_PIX_FMT_YUV420P;
         *pb_has_a = true;
         break;
     case VLC_CODEC_YUVA:
-        *pi_fmt = PIX_FMT_YUV444P;
+        *pi_fmt = AV_PIX_FMT_YUV444P;
         *pb_has_a = true;
         break;
     case VLC_CODEC_RGBA:
-        *pi_fmt = PIX_FMT_BGR32;
+        *pi_fmt = AV_PIX_FMT_BGR32;
         *pb_has_a = true;
         break;
     case VLC_CODEC_ARGB:
-        *pi_fmt = PIX_FMT_BGR32_1;
+        *pi_fmt = AV_PIX_FMT_BGR32_1;
         *pb_has_a = true;
         break;
     case VLC_CODEC_BGRA:
-        *pi_fmt = PIX_FMT_RGB32;
+        *pi_fmt = AV_PIX_FMT_RGB32;
         *pb_has_a = true;
         break;
     case VLC_CODEC_YV12:
-        *pi_fmt = PIX_FMT_YUV420P;
+        *pi_fmt = AV_PIX_FMT_YUV420P;
         *pb_swap_uv = true;
         break;
     case VLC_CODEC_YV9:
-        *pi_fmt = PIX_FMT_YUV410P;
+        *pi_fmt = AV_PIX_FMT_YUV410P;
         *pb_swap_uv = true;
         break;
     default:
@@ -314,7 +308,7 @@ static int GetParameters( ScalerConfigur
     {
         if( p_fmti->i_chroma == VLC_CODEC_YUVP && ALLOW_YUVP )
         {
-            i_fmti = i_fmto = PIX_FMT_GRAY8;
+            i_fmti = i_fmto = AV_PIX_FMT_GRAY8;
             i_sws_flags = SWS_POINT;
         }
     }
@@ -327,9 +321,9 @@ static int GetParameters( ScalerConfigur
      * Without SWS_ACCURATE_RND the quality is really bad for some conversions */
     switch( i_fmto )
     {
-    case PIX_FMT_ARGB:
-    case PIX_FMT_RGBA:
-    case PIX_FMT_ABGR:
+    case AV_PIX_FMT_ARGB:
+    case AV_PIX_FMT_RGBA:
+    case AV_PIX_FMT_ABGR:
         i_sws_flags |= SWS_ACCURATE_RND;
         break;
     }
@@ -403,14 +397,14 @@ static int Init( filter_t *p_filter )
     const unsigned i_fmto_visible_width = p_fmto->i_visible_width * p_sys->i_extend_factor;
     for( int n = 0; n < (cfg.b_has_a ? 2 : 1); n++ )
     {
-        const int i_fmti = n == 0 ? cfg.i_fmti : PIX_FMT_GRAY8;
-        const int i_fmto = n == 0 ? cfg.i_fmto : PIX_FMT_GRAY8;
+        const int i_fmti = n == 0 ? cfg.i_fmti : AV_PIX_FMT_GRAY8;
+        const int i_fmto = n == 0 ? cfg.i_fmto : AV_PIX_FMT_GRAY8;
         struct SwsContext *ctx;
 
         ctx = sws_getContext( i_fmti_visible_width, p_fmti->i_visible_height, i_fmti,
                               i_fmto_visible_width, p_fmto->i_visible_height, i_fmto,
                               cfg.i_sws_flags | p_sys->i_cpu_mask,
-                              p_sys->p_src_filter, p_sys->p_dst_filter, 0 );
+                              p_sys->p_filter, NULL, 0 );
         if( n == 0 )
             p_sys->ctx = ctx;
         else
@@ -468,14 +462,9 @@ static int Init( filter_t *p_filter )
     p_sys->b_swap_uvi = cfg.b_swap_uvi;
     p_sys->b_swap_uvo = cfg.b_swap_uvo;
 
-#if 0
-    msg_Dbg( p_filter, "%ix%i (%ix%i) chroma: %4.4s -> %ix%i (%ix%i) chroma: %4.4s extend by %d",
-             p_fmti->i_visible_width, p_fmti->i_visible_height, p_fmti->i_width, p_fmti->i_height, (char *)&p_fmti->i_chroma,
-             p_fmto->i_visible_width, p_fmto->i_visible_height, p_fmto->i_width, p_fmto->i_height, (char *)&p_fmto->i_chroma,
-             p_sys->i_extend_factor );
-#endif
     return VLC_SUCCESS;
 }
+
 static void Clean( filter_t *p_filter )
 {
     filter_sys_t *p_sys = p_filter->p_sys;
@@ -539,24 +528,24 @@ static void GetPixels( uint8_t *pp_pixel
 }
 
 static void ExtractA( picture_t *p_dst, const picture_t *restrict p_src,
-                      unsigned i_width, unsigned i_height, unsigned offset )
+                      unsigned offset )
 {
     plane_t *d = &p_dst->p[0];
     const plane_t *s = &p_src->p[0];
 
-    for( unsigned y = 0; y < i_height; y++ )
-        for( unsigned x = 0; x < i_width; x++ )
+    for( unsigned y = 0; y < p_dst->format.i_height; y++ )
+        for( unsigned x = 0; x < p_dst->format.i_width; x++ )
             d->p_pixels[y*d->i_pitch+x] = s->p_pixels[y*s->i_pitch+4*x+offset];
 }
 
 static void InjectA( picture_t *p_dst, const picture_t *restrict p_src,
-                     unsigned i_width, unsigned i_height, unsigned offset )
+                     unsigned offset )
 {
     plane_t *d = &p_dst->p[0];
     const plane_t *s = &p_src->p[0];
 
-    for( unsigned y = 0; y < i_height; y++ )
-        for( unsigned x = 0; x < i_width; x++ )
+    for( unsigned y = 0; y < p_src->format.i_height; y++ )
+        for( unsigned x = 0; x < p_src->format.i_width; x++ )
             d->p_pixels[y*d->i_pitch+4*x+offset] = s->p_pixels[y*s->i_pitch+x];
 }
 
@@ -575,7 +564,7 @@ static void CopyPad( picture_t *p_dst, c
         const plane_t *s = &p_src->p[n];
         plane_t *d = &p_dst->p[n];
 
-        for( int y = 0; y < s->i_lines; y++ )
+        for( int y = 0; y < s->i_lines && y < d->i_lines; y++ )
         {
             for( int x = s->i_visible_pitch; x < d->i_visible_pitch; x += s->i_pixel_pitch )
                 memcpy( &d->p_pixels[y*d->i_pitch + x], &d->p_pixels[y*d->i_pitch + s->i_visible_pitch - s->i_pixel_pitch], s->i_pixel_pitch );
@@ -593,8 +582,8 @@ static void SwapUV( picture_t *p_dst, co
 }
 
 static void Convert( filter_t *p_filter, struct SwsContext *ctx,
-                     picture_t *p_dst, picture_t *p_src, int i_height, int i_plane_start, int i_plane_count,
-                     bool b_swap_uvi, bool b_swap_uvo )
+                     picture_t *p_dst, picture_t *p_src, int i_height,
+                     int i_plane_count, bool b_swap_uvi, bool b_swap_uvo )
 {
     filter_sys_t *p_sys = p_filter->p_sys;
     uint8_t palette[AVPALETTE_SIZE];
@@ -605,9 +594,13 @@ static void Convert( filter_t *p_filter,
                p_src, i_plane_count, b_swap_uvi );
     if( p_filter->fmt_in.video.i_chroma == VLC_CODEC_RGBP )
     {
+        video_palette_t *src_pal =
+            p_src->format.p_palette ?
+            p_src->format.p_palette :
+            p_filter->fmt_in.video.p_palette;
         memset( palette, 0, sizeof(palette) );
-        if( p_filter->fmt_in.video.p_palette )
-            memcpy( palette, p_filter->fmt_in.video.p_palette->palette,
+        if( src_pal )
+            memcpy( palette, src_pal->palette,
                     __MIN( sizeof(video_palette_t), AVPALETTE_SIZE ) );
         src[1] = palette;
         src_stride[1] = 4;
@@ -668,23 +661,29 @@ static picture_t *Filter( filter_t *p_fi
     else if( p_sys->b_copy )
         SwapUV( p_dst, p_src );
     else
-        Convert( p_filter, p_sys->ctx, p_dst, p_src, p_fmti->i_visible_height, 0, 3,
-                 p_sys->b_swap_uvi, p_sys->b_swap_uvo );
+    {
+        /* Even if alpha is unused, swscale expects the pointer to be set */
+        const int n_planes = !p_sys->ctxA && (p_src->i_planes == 4 ||
+                             p_dst->i_planes == 4) ? 4 : 3;
+        Convert( p_filter, p_sys->ctx, p_dst, p_src, p_fmti->i_visible_height,
+                 n_planes, p_sys->b_swap_uvi, p_sys->b_swap_uvo );
+    }
     if( p_sys->ctxA )
     {
         /* We extract the A plane to rescale it, and then we reinject it. */
         if( p_fmti->i_chroma == VLC_CODEC_RGBA || p_fmti->i_chroma == VLC_CODEC_BGRA )
-            ExtractA( p_sys->p_src_a, p_src, p_fmti->i_visible_width * p_sys->i_extend_factor, p_fmti->i_visible_height, OFFSET_A );
+            ExtractA( p_sys->p_src_a, p_src, OFFSET_A );
         else if( p_fmti->i_chroma == VLC_CODEC_ARGB )
-            ExtractA( p_sys->p_src_a, p_src, p_fmti->i_visible_width * p_sys->i_extend_factor, p_fmti->i_visible_height, 0 );
+            ExtractA( p_sys->p_src_a, p_src, 0 );
         else
             plane_CopyPixels( p_sys->p_src_a->p, p_src->p+A_PLANE );
 
-        Convert( p_filter, p_sys->ctxA, p_sys->p_dst_a, p_sys->p_src_a, p_fmti->i_visible_height, 0, 1, false, false );
+        Convert( p_filter, p_sys->ctxA, p_sys->p_dst_a, p_sys->p_src_a,
+                 p_fmti->i_visible_height, 1, false, false );
         if( p_fmto->i_chroma == VLC_CODEC_RGBA || p_fmto->i_chroma == VLC_CODEC_BGRA )
-            InjectA( p_dst, p_sys->p_dst_a, p_fmto->i_visible_width * p_sys->i_extend_factor, p_fmto->i_visible_height, OFFSET_A );
+            InjectA( p_dst, p_sys->p_dst_a, OFFSET_A );
         else if( p_fmto->i_chroma == VLC_CODEC_ARGB )
-            InjectA( p_dst, p_sys->p_dst_a, p_fmto->i_visible_width * p_sys->i_extend_factor, p_fmto->i_visible_height, 0 );
+            InjectA( p_dst, p_sys->p_dst_a, 0 );
         else
             plane_CopyPixels( p_dst->p+A_PLANE, p_sys->p_dst_a->p );
     }
